# ТЗ на LLM-кластеризацию обращений контакт-центра

Документ разделен на два уровня зрелости:

1. **MVP (v0.1)** — минимальный функционал, позволяющий проверить гипотезу об LLM‑кластеризации и собрать данные для дальнейших улучшений.
2. **Финальная версия (v1.x)** — расширенный набор возможностей с учетом уроков MVP, автоматизацией вторичных процессов и поддержкой иерархий.

## Общие принципы (актуальны для обеих версий)
- Используем **только LLM** для любых этапов кластеризации; классические ML/векторные модели запрещены.
- Работаем с `pandas.DataFrame`. Столбцы не проверяем через `isinstance`, только сам объект при необходимости.
- Все промежуточные данные и логи складываем в `ai_data`, эксперименты и мини-тесты — в `ai_experiments`, документацию — в `ai_doc`.
- Процесс батчевый и устойчивый к большим объемам обращений; идентификаторы батчей и обращений используются для идемпотентности.
- LLM-провайдер выбирается через `get_llm_provider` (по умолчанию локальная Ollama с `qwen3:30b-a3b`).

## 1. MVP (v0.1)

### 1.1 Цели
- Быстро проверить, можно ли с помощью LLM получать осмысленные кластера обращений и базовые описания.
- Собрать первую статистику покрытия и стоимости, выявить ограничения по батчам и по качеству подсказок.
- Заложить структуру данных и промптов, совместимую с будущими расширениями.

### 1.2 Объем функций MVP
- Очистка текстов обращений, нормализация формата и хранение исходной/очищенной версии.
- Батчевый проход по историческим обращениям (50‑80 обращений в батче).
- Создание новых кластеров через промпт **LLM Cluster Proposer** и привязка обращений к ним в рамках батча.
- Минимальный **Cluster Registry** в памяти/БД с полями: `cluster_id`, `name`, `summary`, `sample_requests`, `created_at`, `count`.
- Простейший **LLM Assignment Judge**, который проверяет, подходит ли обращение под существующие описания; допускается ручное подтверждение спорных кейсов.
- Логирование всех промптов/ответов, хранения в `ai_data`.

### 1.3 Архитектура MVP
1. **Batch Builder** — формирует пачки DataFrame по дате/каналу/приоритету.
2. **LLM Cluster Proposer** — находит темы в пределах батча, возвращает описания, критерии включения, список `request_id`.
3. **Cluster Registry (v0.1)** — простая структура (может быть в памяти, JSON или таблица), умеет добавлять/читать кластера.
4. **LLM Assignment Judge (v0.1)** — промпт «вопрос-ответ», определяющий попадание обращения в существующие кластера.
5. **Pipeline Runner** — orchestrator, который получает DataFrame, вызывает промпты и сохраняет результаты.

### 1.4 Алгоритм обработки батча (MVP)
1. **Подготовка**: очистить тексты (удалить мусор, унифицировать формат), зафиксировать `batch_id`.
2. **Предложение кластеров**: передать LLM список обращений (до `batch_size`) с кратким контекстом о ранее найденных темах; получить список новых кластеров и их признаки.
3. **Присвоение обращений**: пройтись по обращениям, сопоставить их новым и существующим кластерам через Assignment Judge. Разрешается ответ «skip».
4. **Обновление реестра**: сохранить новый кластер, счетчик обращений, 3‑5 примеров, описание «что за проблема и почему важна».
5. **Выходные данные**: DataFrame `request_id`, `cluster_id`, `llm_rationale`, `batch_id`, `confidence (text)`.
6. **Мониторинг**: зафиксировать стоимость токенов, время выполнения, процент обращений без кластера.

### 1.5 Данные и конфигурация (MVP)
- Обязательные столбцы: `request_id`, `text`; дополнительные (`channel`, `priority`, `metadata`) передаются в промпты как контекст.
- Настройки (Pydantic): `batch_size`, `llm_model`, `max_clusters_per_batch`, флаги логирования.
- Команды запуска пайплайна фиксируем в `ai_doc/quickstart.md`.
- в качестве сети использоваь локальную LLM ollama как уже реализован в проекте

### 1.6 Контроль качества MVP
- **Coverage (MVP)** — доля обращений с выданным `cluster_id`.
- **Manual spot-check** — ежедневная ручная проверка нескольких кластеров.
- **LLM sanity check** — короткий промпт «насколько обращения похожи? (low/medium/high)».
- Основная задача MVP: добиться положительного сигнала (>=60% coverage, понятные описания) и подтвердить экономическую выполнимость.

## 2. Финальная версия (v1.x, после MVP)

### 2.1 Дополнительные цели
- Масштабирование на весь поток обращений, включая редкие и сезонные случаи.
- Автоматическое поддержание качества (пересборка, вторые проходы, иерархии).
- Обеспечение объяснимости для бизнес-пользователей и интеграция с существующими процессами.

### 2.2 Расширенные функции
- **Rare Case Buffer**: отдельный пул для обращений без кластера, с последующей микро-кластеризацией.
- **Второй проход по хвосту**: агрегированные summary и macro clustering для повышения покрытия до 80‑90%.
- **Периодическая пересборка** кластеров и их описаний по триггерам (рост данных, падение качества, устаревание).
- **Иерархия уровней 1‑N**: автоматическое построение родительских категорий (Hierarchy Builder).
- **Версионирование описаний**: поле `revision`, история изменений, объяснения, почему описание обновлено.
- **Расширенный Cluster Registry**: хранит уровни иерархии, статус (`active/tentative/split_candidate`), количественные метрики, `assignment_prompt_hint`.
- **Автоматические отчеты** и уведомления о новых критичных кластерах.

### 2.3 Расширенный процесс
1. **Инициализация**: первые `K` батчей формируют устойчивые темы, каждая запись сопровождается `problem_statement`, `why_it_matters`.
2. **Основной батчевый цикл**:
   - Контекст для LLM включает top‑frequency кластера и ближайшие по описанию (ключевые слова из предыдущих ответов).
   - Новые кластера сравниваются с существующими (LLM выбирает merge/keep/subcluster).
3. **Обработка хвоста**:
   - Rare Case Buffer копит обращения до порога `buffer_batch_size`, затем LLM пытается собрать микро-кластера.
   - Если не удалось — маркируем `singular` и отправляем на ручной разбор.
4. **Второй проход**:
   - LLM генерирует summary для оставшихся обращений, выполняет macro clustering.
   - Assignment Judge валидирует новые кластера, при необходимости повторяем до `max_tail_iterations`.
5. **Пересборка**:
   - Триггеры: `rebuild_growth_pct`, доля `skip`, `staleness_days`.
   - LLM пересказывает описание, проверяет необходимость split, обновляет `revision`.
   - Все события логируются в `ai_data/clustering.log`.
6. **Иерархия**:
   - LLM получает список кластеров уровня `n`, формирует родительские категории (до глубины `hierarchy_depth`).
   - Допускается множественная принадлежность (≤2 родителей), описываются критерии включения.

### 2.4 Дополнительные параметры и инфраструктура
- Настройки дополняются: `min_cluster_size`, `buffer_batch_size`, `max_tail_iterations`, `hierarchy_depth`, `rebuild_growth_pct`, `staleness_days`, лимиты на число одновременно активных кластеров.
- Cluster Registry хранится в персистентном хранилище (PostgreSQL/ClickHouse/Parquet) с журналом версий.
- Вводятся REST/CLI команды: `initial_cluster`, `assign_new`, `rebuild`, `hierarchy_refresh`, `macro_tail_pass`.
- Предусматривается блокировка на уровне реестра для параллельных батчей.

### 2.5 Расширенный контроль качества
- **Coverage** (целевое ≥85%), **Tail coverage** (доля обработанного хвоста).
- **Stability** — % обращений, сохранивших кластер после пересборки.
- **Cohesion** — LLM-оценка однородности (1‑5), **Separation** — LLM сравнение пар крупных кластеров.
- **Detection latency** — время между первым обращением и созданием кластера.
- **Manual QA protocol** — регламент выборки и фиксации результатов в `ai_data`.
- Логи промптов содержат `prompt`, `response`, `latency`, `cost_estimate` для аудита.

## 3. Общие требования к реализации
- Все промежуточные файлы, буферы и отчеты — в `ai_data`; временные проверки/мини-тесты — в `ai_experiments`.
- Идемпотентность батчей: повторный запуск не создает дубликатов (ключ `batch_id + request_id`).
- Добавлять новые команды/сценарии в `ai_doc/quickstart.md` как шпаргалку.
- Поддерживать возможность многопоточной обработки, используя блокировки над Cluster Registry.
- Создать тестовые сценарии в `ai_experiments` с моковыми батчами для валидации промптов.

## 4. Потенциальные расширения
- Интеграция обратной связи операторов для корректировки описаний и порогов.
- Выявление сезонности и аномальной нагрузки по кластерам.
- Уведомления при появлении новых критичных кластеров (severity) с автоматическим роутингом.
- Учет SLA и приоритезация кластеров по влиянию на бизнес-метрики.

Документ служит единым источником требований и должен обновляться при переходе между версиями продукта.

